<html lang="en"><head><meta charset="utf-8" /><title>Getting Started -- Gershwin Programming Language</title><meta content="width=device-width, initial-scale=1.0" name="viewport" /><meta content="Gershwin: Stack-based, Concatenative Clojure" name="description" /><meta content="Gershwin programming language Clojure Factor concatenative stack-based" name="keywords" /><!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><link href="/stylesheets/bootstrap/css/bootstrap.min.css" rel="stylesheet" /><link href="/stylesheets/bootstrap/css/bootstrap-responsive.min.css" rel="stylesheet" /><link href="/font-awesome/css/font-awesome.min.css" rel="stylesheet" /><link href="/stylesheets/bootswatch/bootswatch.css" rel="stylesheet" /><link href="/stylesheets/app.css" rel="stylesheet" /></head><body class="preview" data-offset="80" data-spy="scroll" data-target=".subnav" id="top"><!-- Navbar
    ================================================== --><div class="navbar navbar-fixed-top"><div class="navbar-inner"><div class="container"><a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></a><div class="brand"><!-- <img id="mini-logo" src="/images/musical_note.png" /> --><a href="/"><img id="mini-logo" src="/images/logo.png" /></a> <a href="/">Gershwin</a></div><div class="nav-collapse collapse" id="main-menu"><ul class="nav" id="main-menu-left"><li><a href="/news.html">News</a></li><li><a href="/documentation.html">Documentation</a></li><li class="dropdown" id="download-menu"><a class="dropdown-toggle" data-toggle="dropdown" href="#">Download <b class="caret"></b></a><ul class="dropdown-menu"><li><a disabled="disabled" href="javascript:void(0)">Stable Release</a></li><li><a href="http://sourceforge.net/projects/gershwin/files/0.2.0/gershwin-0.2.0-master-406ec77.jar/download" target="_blank">Development Release</a></li></ul></li></ul><ul class="nav pull-right" id="main-menu-right"><li><a href="https://github.com/gershwin/gershwin" rel="tooltip" target="_blank" title="Gershwin Github source repository"><i class="icon-large icon-github"></i> Project on Github</a></li></ul></div></div></div></div><div class="container"><!-- Masthead
================================================== --><header class="jumbotron subhead" id="overview"><div class="row"><div class="span6"><img alt="Gershwin Programming Language Logo" id="logo" src="/images/logo.png" title="Gershwin Programming Language" /><h1>Gershwin</h1><p class="lead">Stack-based, Concatenative Clojure</p></div><div class="span6"></div></div></header><div><div class="row"><div class="span8"><h2>Getting Started</h2><p>Gershwin is an extension of Clojure. It helps to start by pointing out how Gershwin differs from Clojure:</p>
<ul>
  <li>Gershwin has <em>words</em> instead of named functions</li>
  <li>Gershwin has <em>quotations</em> instead of anonymous functions</li>
  <li>Gershwin puts everything on the stack</li>
</ul><p>We will cover these features in more detail in the sections that follow. Note that these features are additive; the goal of Gershwin is to maintain complete compatibility with Clojure while offering stack-based, concatenative features on top of what Clojure already provides.</p><p>So if you&rsquo;re not using any of the bulleted features listed above, you&rsquo;re just writing Clojure.</p><h3>REPL</h3><p>You can start a bare-bones Gershwin REPL much like a Clojure one. <a href="http://sourceforge.net/projects/gershwin/files">Download the latest Gershwin</a> and run the following:</p>
<pre><code>java -cp gershwin.jar gershwin.main
</code></pre><p>If you start the REPL in this way, use tools like <a href="">rlwrap</a>, <a href="">ledit</a>, or Emacs&rsquo; inferior Lisp support for a richer editing experience.</p><p>A more feature-rich alternative that also presents more of a learning curve is nREPL. For those familiar with Clojure&rsquo;s nREPL, a Gershwin-compatible version of tools.nrepl is available (<a href="https://github.com/gershwin/tools.nrepl">code</a>, <a href="https://sourceforge.net/projects/gershwin/files/tools.nrepl/?">JAR download</a>). You can start the nREPL server by including the JAR on your classpath and then invoking it as follows (taken from the <a href="https://github.com/clojure/tools.nrepl/blob/master/README.md">tools.nrepl README</a>):</p>
<pre><code class="clj">(require &#39;[clojure.tools.nrepl.server :refer [start-server stop-server]])
(defonce server (start-server :port 7890))
;; To stop the server:
;; (stop-server server)
</code></pre><p>At this point, you can connect with the nREPL client of your choosing, to include <a href="https://github.com/kingtim/nrepl.el">nrepl.el</a> for Emacs, <a href="">foreplay.vim</a> for Vim, <a href="https://github.com/trptcolin/reply/">Reply</a> (what Leiningen 2 uses for <code>lein repl</code>), and <a href="http://code.google.com/p/counterclockwise/">Counterclockwise</a> for Eclipse.</p><h3>Hello, World</h3><p>The REPL starts and you&rsquo;re greeted with a familiar Clojure-style REPL that indicates you&rsquo;re in the <code>user</code> namespace. Now, in addition to having all of Clojure at your fingertips, you also have access to Gershwin.</p><p>Try the following at the REPL:</p>
<pre><code>user=&gt; 2

--- Data Stack:
2
user=&gt; 3

--- Data Stack:
2
3
user=&gt; +

--- Data Stack:
5
</code></pre><p>You just put the value <code>2</code> on the top of the stack, then the value <code>3</code>. Finally, you entered the <code>+</code> word.</p><p>When Gershwin encounters a word, it invokes it. A word takes values off the top of the stack, does something with them, and puts 0 or more values back on the stack. The <code>+</code> word takes two values and puts their sum on top of the stack. In this case, the value <code>5</code> is all that remains on the top of the stack.</p><h3>Defining Words</h3><p>Clojure provides the functions <code>inc</code> and <code>dec</code> that add or subtract the value <code>1</code> from their argument. If these weren&rsquo;t implemented with methods from the lower-level <code>clojure.lang.Numbers</code> class, their implementation might look like this:</p>
<pre><code>(defn inc [n] (+ n 1))
(defn dec [n] (- n 1))
</code></pre><p>Or by using partial application:</p>
<pre><code>(def inc (partial + 1))
(def dec (partial - 1))
</code></pre><p>Here&rsquo;s what they look like in Gershwin:</p>
<pre><code>: inc [n -- n] 1 + .
: dec [n -- n] 1 - .
</code></pre><p>Let&rsquo;s break down the word definitions into parts.</p><p>The <code>:</code> character followed by a space indicates the beginning of a word definition. This is one of the two additions to Clojure syntax that Gershwin introduces.</p><p>The next form must be a symbol that names the word, in this case <code>inc</code> and <code>dec</code>. Symbols can consist of any character legal in Clojure symbols, including dashes, question marks, exclamation points, etc.</p><p>The next required element is the <em>stack effect</em> declaration. A stack effect declaration is written as a Clojure vector of symbols, specifying what items are taken off the stack followed by <code>--</code> followed by how many items are put back on the stack. While optional in some stack-based languages, Gershwin requires you to indicate what the intended stack effect of a given word will be. Currently this is used for documentation purposes only, but future versions of Gershwin will perform some sanity checks on stack effects in a program based on this information.</p><p><strong>Note:</strong> The stack effect is not a declaration of parameters, nor do the symbols inside the stack effect have any bearing on the word&rsquo;s definition. You can use whatever symbols make most sense to describe the stack effect of your words.</p><p>After the stack effect declaration is the main definition of the word, in this case <code>1 +</code> and <code>1 -</code> for <code>inc</code> and <code>dec</code> respectively. If this is your first exposure to concatenative languages, you may be wondering where the rest of the function is. Remember that <code>+</code> takes two items off the stack and adds them together; similarly, <code>-</code> takes two items off the stack and subtracts one from the other. The <code>inc</code> and <code>dec</code> words simply provide the <code>+</code> and <code>-</code> words with their second &ldquo;parameter&rdquo; and will acquire their first &ldquo;parameter&rdquo; when used in a program.</p><p>Let&rsquo;s see what it&rsquo;s like to use them:</p>
<pre><code>user=&gt; 2 inc

--- Data Stack:
3
</code></pre><p>This expression puts <code>3</code> on the top of the stack. But how? Let&rsquo;s replace the word <code>inc</code> with its definition and see if it makes it any clearer:</p>
<pre><code>user=&gt; 2 1 +

--- Data Stack:
3
</code></pre><p>Now the code looks like our first example at the beginning of this page. Put <code>2</code> on the stack, then <code>1</code>, then invoke the <code>+</code> word which takes those top two values and adds them together, putting the result on the top of the stack. The <code>inc</code> word simply captured the <code>1 +</code> portion of this program, which behaves no differently than if we entered it all explicitly.</p><p>This simple example demonstrates the absolute straight-forwardness of code factoring in a concatenative language. Instead of worrying about defining formal parameters for new functions, passing in arguments and directing the result in the flow of your program, a concatenative program consists of a left-to-right flow that consists of (1) adding data items to the top of the stack and (2) evaluating words that work with that stack. This allows you to replace arbitrary parts of your programs with word definitions simply by cutting-and-pasting your code into new word definitions.</p><h3>Quotations</h3><p>In addition to word definitions, the other major conceptual addition that Gershwin makes to the Clojure arsenal is that of <em>quotations</em>. Code wrapped in a quotation is not executed immediately; it is only evaluated when the quotation is invoked either explicitly or when used with certain Gershwin core words.</p><p>Quotations form the basis of the implementation of Gershwin&rsquo;s shuffle words (core words for moving items around on the top of the stack), conditionals (<code>if</code>, <code>when</code>, etc.), unit testing framework, and also fulfil the role that function values play in other functional programming languages (e.g., as arguments to <code>map</code>, <code>filter</code>, etc).</p><p>Let&rsquo;s take a look at a simple conditional expression:</p>
<pre><code>: is-greater &quot;Print a message based on whether a is greater than or less than b.&quot;
  [a b --]
  &gt; #[ &quot;yep, greater&quot; println ] #[ &quot;nope, lesser&quot; println ] if .
</code></pre><p>The word <code>is-greater</code> begins with the <code>&gt;</code> word that takes the top two items off the stack and puts <code>true</code> on the top of the stack if the first item is greater than the second, <code>false</code> otherwise.</p><p>We then see three forms: two quotations and the <code>if</code> word. The <code>if</code> word expects to find a value followed by two quotations, the first of which represents the &ldquo;then&rdquo; logical branch and the second of which represents the &ldquo;else&rdquo; branch. We say that it first expects a &ldquo;value&rdquo; and not simply a &ldquo;boolean,&rdquo; because Gershwin follows Clojure truthy/falsey semantics, such that anything other than <code>nil</code> or <code>false</code> represents a truthy value for conditional expressions.</p><p>So if we were to use <code>is-greater</code>:</p>
<pre><code>user=&gt; 2 3 is-greater
nope, lesser

--- Data Stack:
</code></pre><p>The <code>2</code> and <code>3</code> are taken off the stack by the <code>&gt;</code> word, which then puts <code>false</code> on the top of the stack. The <code>if</code> word then consumes that <code>false</code> value and the two quotations that follow it. Since the value <code>false</code> is falsey, <code>if</code> invokes the else-quotation which, in this case, prints the string <code>&quot;nope, lesser&quot;</code> followed by a line break.</p><p><strong>Note:</strong> Unlike Clojure functions which always return a value, if only <code>nil</code>, Gershwin allows for words that do not take items off or put items on the stack.</p><h3>Clojure Interop</h3><p>As mentioned above, compatibility with Clojure is Gershwin&rsquo;s prime directive. Most words in Gershwin core are implemented as direct delegates to core Clojure functions. Let&rsquo;s take a look at how the <code>+</code> word is defined:</p>
<pre><code>: + [n n -- n] (+ (pop-it) (pop-it)) .
</code></pre><p>This looks like the other word definitions we&rsquo;ve seen so far, except its entire implementation is a Clojure form, <code>(+ (pop-it) (pop-it))</code>. Since this is neither a word or a quotation, Gershwin delegates the reading and evaluation of this to Clojure and puts the return value on the top of the stack. The <code>pop-it</code> function is a low-level utility that removes the top-most item of the stack, so we&rsquo;re simply popping the two top-most items and passing them as arguments to the <code>clojure.core/+</code> function.</p><p>How can we use the <code>+</code> symbol both as a word definition and a Clojure function? Inside of a Clojure expression, Gershwin leaves Clojure to resolve symbols. In Gershwin word definitions, quotations, at the Gershwin REPL and when a Gershwin script file is evaluated, Gershwin first attempts to resolve a symbol as a var referencing a Gershwin word, and only if that fails falls back to Clojure resolution. Gershwin var&rsquo;s and Clojure var&rsquo;s are kept separate (albeit with name munging), so you don&rsquo;t need to worry (too much) about name clashes.</p><p>To make the distinction between Gershwin word var&rsquo;s and regular Clojure var&rsquo;s, Gershwin provides an extra reader macro <code>#*</code> for Gershwin word var&rsquo;s and the <code>require-words</code> function for requiring Gershwin namespaces (specifically required when using <code>:refer</code> to refer specific Gershwin words from another namespace).</p></div><div class="span4"><div class="well"><h3><i class="icon-download"> Download</i></h3><ul><li><a disabled="disabled" href="javascript:void(0)">Stable Release</a></li><li><a href="http://sourceforge.net/projects/gershwin/files/0.2.0/gershwin-0.2.0-master-406ec77.jar/download">Development Release</a></li></ul></div></div></div></div><br /><br /><br /><br /><hr /><footer id="footer"><p class="pull-right"><a href="#top">Back to top</a></p><div class="links"><p><a href="https://github.com/gershwin/gershwin"><i class="icon-large icon-github"></i> Source Repository</a><a href="/documentation.html"><i class="icon-book"></i> Documentation</a><a href="https://github.com/gershwin/gershwin/issues"><i class="icon-tasks"></i> Issues/Bugs</a></p><p><a href="/rss-feed"><i class="icon-rss"></i> RSS Feed</a><a href="https://twitter.com/gershwinlang"><i class="icon-twitter"></i> @gershwinlang</a></p></div><p>Web design created by <a href="http://thomaspark.me">Thomas Park</a>.
        Web design code licensed under the <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License v2.0</a>.<br />
        Web design based on <a href="http://twitter.github.com/bootstrap/">Bootstrap</a>. Icons from <a href="http://fortawesome.github.com/Font-Awesome/">Font Awesome</a>. Web fonts from <a href="http://www.google.com/webfonts">Google</a>. Logo by Daniel Gregoire.</p><br /></footer></div><!-- /container --><!-- Le javascript
    ================================================== --><!-- Placed at the end of the document so the pages load faster --><script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/jquery-smooth-scroll/1.4.10/jquery.smooth-scroll.min.js"></script><script src="/javascripts/bootstrap/bootstrap.min.js"></script></body></html>